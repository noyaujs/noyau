import { stat, mkdir, writeFile } from "node:fs/promises";
import { type Noyau, type TSReference } from "@noyau/schema";
import { isAbsolute, join, relative, resolve } from "pathe";
import { type PackageJson, type TSConfig } from "pkg-types";
import { tryImportModule } from "@noyau/kit";

export const writeTypes = async (noyau: Noyau) => {
  const tsConfig: TSConfig = {
    compilerOptions: {
      forceConsistentCasingInFileNames: true,
      jsx: "preserve",
      target: "ESNext",
      module: "ESNext",
      moduleResolution: "Node",
      skipLibCheck: true,
      // strict: noyau.options.typescript?.strict ?? false,
      strict: false,
      allowJs: true,
      noEmit: true,
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      types: ["node"],
      baseUrl: relative(noyau.options.buildDir, noyau.options.rootDir),
      paths: {},
    },
    include: [
      "./noyau.d.ts",
      join(relative(noyau.options.buildDir, noyau.options.rootDir), "**/*"),
      ...(noyau.options.srcDir !== noyau.options.rootDir
        ? [join(relative(noyau.options.buildDir, noyau.options.srcDir), "**/*")]
        : []),
    ],
    exclude: [
      // nitro generate output: https://github.com/noyau/noyau/blob/main/packages/noyau/src/core/nitro.ts#L186
      relative(noyau.options.buildDir, resolve(noyau.options.rootDir, "dist")),
    ],
  };

  const aliases: Record<string, string> = {
    ...noyau.options.alias,
    "#build": noyau.options.buildDir,
  };

  for (const alias in aliases) {
    // if (excludedAlias.some((re) => re.test(alias))) {
    //   continue;
    // }
    const relativePath = isAbsolute(aliases[alias])
      ? relative(noyau.options.rootDir, aliases[alias]) || "."
      : aliases[alias];

    const stats = await stat(
      resolve(noyau.options.rootDir, relativePath)
    ).catch(() => null /* file does not exist */);
    tsConfig.compilerOptions = tsConfig.compilerOptions || {};
    if (stats?.isDirectory()) {
      tsConfig.compilerOptions.paths[alias] = [relativePath];
      tsConfig.compilerOptions.paths[`${alias}/*`] = [`${relativePath}/*`];
    } else {
      tsConfig.compilerOptions.paths[alias] = [
        relativePath.replace(/(?<=\w)\.\w+$/g, ""),
      ]; /* remove extension */
    }
  }
  const references: TSReference[] = await Promise.all(
    [...noyau.options.modules]
      .filter((f): f is string => typeof f === "string")
      .map(async (id) => ({
        types:
          (
            await tryImportModule<PackageJson>(
              `${id}/package.json`,
              noyau.options.modulesDir
            )
          )?.name || id,
      }))
  );

  const declarations: string[] = [];

  await noyau.callHook("types:prepare", { references, declarations, tsConfig });

  const declaration = [
    ...references.map((ref) => {
      if ("path" in ref && isAbsolute(ref.path)) {
        ref.path = relative(noyau.options.buildDir, ref.path);
      }
      return `/// <reference ${renderAttrs(ref)} />`;
    }),
    ...declarations,
    "",
    "export {}",
    "",
  ].join("\n");

  const GeneratedBy = "// Generated by noyau";

  const tsConfigPath = resolve(noyau.options.buildDir, "tsconfig.json");
  await mkdir(noyau.options.buildDir, { recursive: true });
  await writeFile(
    tsConfigPath,
    GeneratedBy + "\n" + JSON.stringify(tsConfig, null, 2)
  );

  const declarationPath = resolve(noyau.options.buildDir, "noyau.d.ts");
  await writeFile(declarationPath, GeneratedBy + "\n" + declaration);
};

function renderAttrs(obj: Record<string, string>) {
  return Object.entries(obj)
    .map((e) => renderAttr(e[0], e[1]))
    .join(" ");
}

function renderAttr(key: string, value: string) {
  return value ? `${key}="${value}"` : "";
}
